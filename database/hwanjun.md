# 📌 RDB vs NoSQL

## DB-006. RDB와 NoSQL의 차이

### RDB (Relational Database)

- **정형 데이터** 기반
  → 컬럼과 타입이 명확히 정의된 데이터
- 테이블 + 스키마 구조
- SQL 사용
- **ACID 트랜잭션 보장**
- 강한 일관성(Strong Consistency)

> MySQL, PostgreSQL, Oracle

🔎 **용어 정리**

- **정형 데이터**: 구조가 고정된 데이터 (컬럼, 타입 명확)
- **스키마(Schema)**: 테이블 구조에 대한 사전 정의
- **ACID**
  - **Atomicity**: 전부 성공 or 전부 실패
  - **Consistency**: 제약 조건 유지
  - **Isolation**: 트랜잭션 간 간섭 없음
  - **Durability**: 커밋 후 영구 저장

---

### NoSQL (Not Only SQL)

- **비정형 / 반정형 데이터** 처리
  → 데이터 구조가 유동적
- 스키마 유연
- SQL이 아닌 자체 Query 모델
- **확장성(Scale-out)에 최적화**
- 최종 일관성(Eventual Consistency) 채택 가능

**대표 유형**

- Key-Value (Redis)
- Document (MongoDB)
- Column (Cassandra)
- Graph (Neo4j)

🔎 **용어 정리**

- **비정형 데이터**: 구조가 없는 데이터 (로그, JSON 등)
- **Scale-out**: 서버 대수를 늘려 성능 확장
- **Eventual Consistency**: 즉시 일관성은 없지만 시간이 지나면 맞아짐

---

### 핵심 차이 요약

| 구분        | RDB      | NoSQL         |
| ----------- | -------- | ------------- |
| 데이터 구조 | 테이블   | 유연          |
| 스키마      | 고정     | 동적          |
| 트랜잭션    | ACID     | 제한적        |
| 확장 방식   | Scale-up | Scale-out     |
| 일관성      | Strong   | Eventual 가능 |

🔎 **추가 용어**

- **Scale-up**: CPU/RAM을 더 좋은 장비로 교체
- **Strong Consistency**: 쓰기 직후 항상 최신 값 조회

---

## DB-007. NoSQL의 강점과 약점

### ✅ 강점

- 수평 확장(Scale-out) 용이
- 대용량 트래픽 처리에 강함
- 스키마 변경 비용 낮음
- 특정 목적(캐시, 로그, 세션)에 최적화

🔎 **왜 강한가?**

- 대부분 **분산을 전제로 설계**
- 단순 연산(O(1) Key 접근)에 최적화

---

### ❌ 약점

- 복잡한 Join 불가 또는 비효율
- 트랜잭션 제약
- 데이터 정합성 관리가 어려움
- 설계 실수 시 데이터 품질 저하

🔎 **정합성 문제란?**

- 동일 데이터가 노드마다 다를 수 있음
- 애플리케이션에서 직접 보정 필요

---

## DB-008. RDB가 NoSQL보다 부하가 걸릴 수 있는 이유

> “RDB가 느리다”가 아니라 “특정 상황에서 부하가 커질 수 있다”

---

### 이유 ① 트랜잭션 비용

- Lock
- Undo / Redo Log
- MVCC 관리

→ 쓰기 부하 증가 시 비용 상승

🔎 **용어 정리**

- **Lock**: 동시에 같은 데이터를 건드릴 때 “충돌”을 막기 위해 접근을 제한하는 장치
- **Undo Log**: 롤백용 로그
- **Redo Log**: 장애 복구용 로그
- **MVCC**: 같은 데이터의 여러 버전(스냅샷)을 만들어, 읽기와 쓰기가 서로 락으로 방해하지 않게 하는 동시성 제어 방식

### 이유 ② Join 연산

- 다중 테이블 Join
- 인덱스 미스 시 Full Scan

🔎 **Join 비용이 큰 이유**

- 여러 테이블을 메모리/디스크에서 동시에 탐색
- 데이터 양 증가 시 기하급수적으로 비용 증가

### 이유 ③ 확장 한계

- RDB는 기본적으로 **Scale-up 중심**
- 단일 노드 성능이 병목이 되기 쉬움

**반대로**

단순 Key 조회나 카운팅은 NoSQL이 유리하지만, 복잡한 조건 검색, 정합성 기반 계산은 RDB가 더 효율적인 경우도 많다.

---

## DB-009. NoSQL 사용 경험 & 선택 이유

> 로그인 시도 횟수 제한(Rate Limiting)을 구현할 때 Redis를 사용했습니다.
>
> 요청 횟수를 빠르게 증가시키고 TTL로 자동 만료시키는 구조가 필요했는데,
>
> 트랜잭션 정합성보다 **속도와 단순한 카운팅**이 중요했기 때문에 RDB 대신 Redis를 선택했습니다.

---

# 📌 클러스터링 및 분산 DB

## DB-027. RDB / NoSQL의 클러스터링 & 레플리케이션

### RDBMS

- **Master – Slave 구조**
- Master: Write
- Slave: Read
- Replication 기반

**특징**

- 구조 단순
- Write 확장 어려움

---

### NoSQL

- **Peer-to-Peer 구조**
- 자동 샤딩
- 데이터 분산 저장

🔎 **Peer-to-Peer**

- 특정 Master 없음
- 모든 노드가 동등한 역할

> Cassandra, MongoDB 등

---

## DB-028. 분산 환경에서 트랜잭션 관리

### 방법 ① 2PC (Two-Phase Commit)

- Prepare → Commit
- 강한 일관성
- 성능/가용성 저하

### **2PC가 왜 느리고 위험한가?**

- 모든 참여자가 “준비(prepare)”를 끝낼 때까지 기다림
- 코디네이터/참여자 장애가 나면 **전체가 멈출 수 있음(Blocking)**
  → 강한 정합성은 얻지만 가용성/성능 손해

---

### 방법 ② Saga 패턴

- 로컬 트랜잭션 + 보상 트랜잭션
- Event 기반
- MSA에서 주로 사용

### **Saga가 왜 실무에서 많이 쓰나?**

- 각 서비스는 **자기 DB만 로컬 트랜잭션으로 커밋**
- 실패하면 “되돌리는 작업(보상 트랜잭션)”을 실행
  → 분산락 없이도 흐름을 맞출 수 있음(대신 최종일관성)

---

### 방법 ③ Eventual Consistency

- 즉시 일관성 포기
- 시간 경과 후 정합성 보장

---

## DB-029. Slave 동기화 전 정합성 보장 방법

### 1️⃣ Read-after-write 문제 해결

- Write 직후에는 Master 조회
- 또는 Sticky Session

### **🔎 Read-after-write가 왜 생기나?**

**상황**

- 사용자가 프로필을 수정함(WRITE는 Master로 들어감)
- 바로 이어서 조회 화면을 새로고침(READ가 Slave로 가면)

**문제**

- Slave는 복제가 아직 안 끝나서 “수정 전 데이터”를 줄 수 있음
  → 방금 저장했는데 저장 안 된 것처럼 보임

---

### 2️⃣ Version / Timestamp 비교

- 최신 버전 우선 사용

---

### 3️⃣ Cache 활용

- Write-through / Write-back 전략

### **🔎 Write-through**

> Cache와 DB에 **동시에 기록**

- 장점: Cache와 DB가 항상 맞아 떨어질 확률이 높음
- 단점: 쓰기 지연이 증가(항상 DB까지 가야 함)

### **🔎 Write-back(Write-behind)**

> Cache에 먼저 기록하고 DB는 **나중에 비동기 반영**

- 장점: 쓰기가 빠름(사용자 체감 좋음)
- 단점: Cache 장애 시 DB에 반영 전 데이터 유실 위험
  → “데이터 중요도 높은 곳”엔 조심

---

## DB-030. 레플리케이션 vs 샤딩 선택

### 레플리케이션

> 같은 데이터를 여러 대에 복사해서 READ를 분산

- “조회가 많을 때” 가장 먼저 고려
- write는 여전히 master 중심이라 한계

### 샤딩

> 샤딩 키를 기준으로 데이터를 나눠서 여러 대에 저장해서 WRITE/데이터 크기를 분산

- 데이터가 너무 커져서 한 DB에 못 담거나
- write가 너무 많아서 한 master가 감당 못 할 때

※ 샤딩의 핵심은 ‘샤딩 키 선택’이며, 잘못 선택하면 특정 샤드에 부하가 몰리는 핫스팟 문제가 발생할 수 있다.

### 선택 기준 (면접 답변 예시)

> “Read 트래픽이 많다면 레플리케이션, Write 트래픽과 데이터 규모가 크다면 샤딩을 선택하겠습니다.”

---

# 📌 성능 및 확장성

## DB-050. 트래픽 증가 시 DB 대응 전략

### 단계별 접근

1. 쿼리 최적화 (Index, N+1 제거)
2. 캐시 도입 (Redis)
3. Read Replica 추가
4. 샤딩
5. CQRS 적용

🔎 **CQRS**

- Read 모델과 Write 모델 분리

---

## DB-051. DB 분산 없이 트래픽 감당하는 방법

### 1️⃣ 캐시

- DB 부하의 70~90% 제거 가능

### 2️⃣ Connection Pool 튜닝

- 과도한 커넥션 방지

---

### 3️⃣ 비동기 처리

- Write 지연 허용

### 4️⃣ 데이터 모델 개선

- Denormalization

🔎 **Denormalization**

- Join 감소를 위해 일부 중복 허용
