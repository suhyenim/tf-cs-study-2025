## 📌 트랜잭션

### DB-010
트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.

### 트랜잭션
- DB의 상태를 변화시키는 하나의 논리적 작업 단위. 트랜잭션은 다음의 ACID 원칙을 만족해야 한다.

1. Atomicity(원자성)
- 트랜잭션 내 작업은 전부 성공하거나 전부 롤백되어야 함
- 일부만 반영되는 상태는 허용되지 않음
- Spring Boot 기준으로 @Transactional 미적용, 예외 처리 오류 시 발생 가능

2. Consistency(일관성)
- 트랜잭션 전후에 DB 제약 조건(무결성 규칙)은 항상 만족되어야 함
- ex)
    - 비즈니스 제약 조건 검증 로직 부재(포인트 차감 기능이 있을 경우 point 필드는 양수로 제한해야 함)
    - DB 제약 조건 위배(PK, FK 관련)

3. Isolation(격리성)
- 동시에 실행되는 트랜잭션은 서로 간섭하지 않아야 함
- 마치 순차적으로 실행된 것처럼 보이도록 보장
- ex)
    - 좌석 예약 서비스에서 동시에 두 요청이 같은 좌석 조회(동시성 문제) -> 두 요청 모두 commit 된다면 중복 예약 발생
    - 낙관적 락, 비관적 락, 격리 레벨 설정 등을 적절히 적용해야 함

4. Durability(지속성)
- 커밋된 트랜잭션의 결과는 시스템 장애가 발생해도 유지되어야 함

즉 트랜잭션은 데이터의 정확성과 신뢰성을 보장하기 위한 최소 작업 단위이며, ACID는 이를 보장하기 위한 속성이다.

---

### DB-011
ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?

주로 Redo Log (Write-Ahead Logging)을 통해 보장한다.

메커니즘
1. 변경 내용을 메모리 버퍼에 먼저 반영
2. 동시에 변경 로그를 Redo Log에 기록
3. Redo Log가 디스크에 기록된 후에만 COMMIT 성공
4. 장애 발생 시 디스크에 남아 있는 Redo Log를 기반으로 변경 사항 재적용

-> 데이터보다 로그를 먼저 디스크에 기록한다(WAL, Write-Ahead Logging)
- 즉 데이터 파일은 깨져도 Redo Log만 있으면 복구 가능
- SSD, HDD 등 비휘발성 저장소에 로그를 기록

---

### DB-012
트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?

게임 타임라인 업데이트 관련 트랜잭션 흐름(게임 상태/점수/타임라인이 조금이라도 꼬이면 안 되는 핵심 도메인 로직)

1. 트랜잭션 시작
- @Transactional 이 붙은 타임라인 저장 로직 호출 시, 스프링이 트랜잭션 시작
2. 게임 로딩 + 잠금
- DB 에서 Game 조회하면서 비관적 잠금(SELECT ... FOR UPDATE) 걸림
- 같은 Game 을 만지는 다른 트랜잭션은 여기서 대기 또는 예외
3. 비즈니스 검증
- 게임 상태가 타임라인 등록 가능한지 확인, 아니면 예외 → 트랜잭션 롤백
4. 도메인 상태 변경 준비
- 게임/타임라인 관련 도메인 상태 변경 로직 실행 (점수, 시간, 상태 등)
5. 영속화
- save(timeline) → Timeline INSERT (또는 flush 시점에 반영)
- 여전히 같은 트랜잭션 안에서 처리됨
6. 정상 종료 시 커밋
- 메서드 끝까지 예외 없으면 스프링이 트랜잭션 커밋:
  - Timeline 저장, Game 등 변경된 엔티티 상태 flush, 잠금 해제
7. 예외 발생 시 롤백
- 위 과정 중 어느 단계에서든 예외 발생 → 스프링이 전체 트랜잭션 롤백:
  - Timeline 저장 취소, Game 상태 변경도 취소, DB는 호출 전 상태로 유지

---

### DB-013
읽기에는 트랜잭션을 걸지 않아도 될까요?

경우에 따라 다르지만, 정합성이 중요한 데이터의 경우 트랜잭션이 필요하다.

- 트랜잭션이 딱히 필요없는 경우
    - 단순 조회 로직
    - 정합성이 크게 중요하지 않은 통계성 조회
- 트랜잭션이 필요한 읽기
    - 읽은 값을 기반으로 비즈니스 로직을 수행하여 쓰기 연산이 들어가는 경우
    - 반복 읽기의 일관성이 중요한 경우
    - 동시성 이슈가 있는 경우

---

### DB-014
트랜잭션 격리 레벨에 대해 설명해 주세요.

### 격리 레벨(Isolation Level)
- 동시에 실행되는 트랜잭션 간 데이터 접근 허용 범위를 정의한다.

1. READ UNCOMMITTED
- 커밋되지 않은 데이터 읽기 가능
- Dirty Read 발생

2. READ COMMITTED
- 커밋된 데이터만 읽기 가능
- Non-repeatable Read 발생

3. REPEATABLE READ
- 같은 데이터를 여러 번 읽어도 동일
- Phantom Read 가능

4. SERIALIZABLE
- 가장 높은 격리 수준
- 트랜잭션을 순차 실행한 것처럼 동작
- 성능 저하 큼

---

### DB-015
모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?

보통 4가지 모두의 레벨을 모두 구현하고 있지는 않다.

이유
1. 성능과 구현 복잡도: SERIALIZABLE은 락 비용이 매우 큼
2. 스토리지 엔진 구조 차이
3. 실제 사용 패턴: 대부분의 서비스는 READ COMMITTED / REPEATABLE READ로 충분

---

### DB-016
만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.

1. Undo 영역
- 트랜잭션 수행 중, 변경되기 “이전 값”을 저장하는 공간
- Undo Log의 목적
  - 1) 트랜잭션 롤백(**Atomicity**)
    - 트랜잭션 실패 → Undo Log를 사용해 원래 값으로 되돌림
    - 일부 쿼리만 반영되는 상태 방지
  - 2) MVCC 기반 일관된 읽기(**Isolation**)
    - 다른 트랜잭션이 커밋하기 전의 데이터
    - 또는 과거 시점의 스냅샷 데이터를 제공
- 즉 Undo는 “과거의 데이터 버전”을 보관하는 역할

2. Redo 영역
- 트랜잭션에서 변경된 내용을 다시 적용하기 위한 로그 저장 공간
- Redo Log의 목적: Durability(지속성) 보장
  - 데이터 변경 발생 시 변경 내용을 Redo Log에 먼저 기록
  - 장애 발생 시 Redo Log를 기반으로 변경 내용을 재적용 가능
- 즉 Redo는 미래에 다시 복구할 변경 기록


| 구분   | Undo                 | Redo       |
| ---- | -------------------- | ---------- |
| 목적   | 롤백 / 읽기 일관성          | 장애 복구      |
| 기준   | 변경 전                 | 변경 후       |
| ACID | Atomicity, Isolation | Durability |

---

### DB-017
그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?

데이터를 실제로 어떻게 저장하고, 읽고, 락을 관리할지를 담당하는 DB 내부 모듈
-> DB의 “파일 시스템 + 동시성 제어 + 트랜잭션 구현체” 역할

주요 책임
- 데이터 저장 방식
- 인덱스 관리
- 트랜잭션 지원 여부
- 락/MVCC 처리
- 복구 로직

