### HTTP 프로토콜의 특징

- 비연결 지향(Connectionless)
    - 클라이언트가 req를 서버에 보내고, 서버가 클라이언트의 요청에 맞는 res를 보내면 바로 연결을 끊는다.
- 상태정보 유지 안 함(Stateless)
    - 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않음

### 쿠키와 세션의 필요성

- HTTP 프로토콜은 위와 같은 특징으로 모든 요청 간 의존관계가 없다
- 즉, 현재 접속한 사용자가 이전에 접속했던 사요자와 같은 사용자인지 아닌지 알 수 있는 방법이 없음
- 계속해서 연결을 유지하지 않기 때문에 리소스 낭비가 줄어드는 것이 큰 장점이지만, 통신할 때마다 새로 연결하기 때문에 클라이언트는 매 요청마다 인증을 해야한다는 단점이 있음
- 이전 요청과 현재 요청이 같은 사용자의 요청인지 알기 위해서는 상태를 유지해야 함
- HTTP 프로토콜에서 상태를 유지하기 위한 기술로 쿠키와 세션이 있음

### 쿠키(Cookie)란?

- 개념
    - 클라이언트 로컬에 저장되는 키와 값이 들어있는 파일
    - 이름, 값, 유효 시간, 경로 등을 포함하고 있음
    - 클라이언트의 상태 정보를 브라우저에 저장하여 참조
- 구성 요소
    - 쿠키의 이름(name)
    - 쿠키의 값(value)
    - 쿠키의 만료시간(Expires)
    - 쿠키를 전송할 도메인 이름(Domain)
    - 쿠키를 전송할 경로(Path)
    - 보안 연결 여부(Secure)
    - HttpOnly 여부(HttpOnly)
- 동작 방식
    
    <img width="642" height="497" alt="image" src="https://github.com/user-attachments/assets/6a013733-16b2-4d8a-9810-28558bd2fef2" />

    
    1. 웹브라우저가 서버에 요청
    2. 상태를 유지하고 싶은 값을 쿠키(cookie)로 생성
    3. 서버가 응답할 때 HTTP 헤더(Set-Cookie)에 쿠키를 포함해서 전송
        
        <aside>
        
        Set-Cookie: id=doy
        
        </aside>
        
    4. 전달받은 쿠키는 웹브라우저에서 관리하고 있다가, 다음 요청 때 쿠키를 HTTP 헤더에 넣어서 전송
        
        <aside>
        
        cookie: id=doy
        
        </aside>
        
    5. 서버에서는 쿠키 정보를 읽어 이전 상태 정보를 확인한 후 응답
- 쿠키 사용 예
    - 아이디, 비밀번호 저장
    - 쇼핑몰 장바구니

### 세션(Session)이란?

- 개념
    - 일정 시간동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술
    - 즉, 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태
- 동작 방식
    
    <img width="935" height="497" alt="image" src="https://github.com/user-attachments/assets/daa61f8c-e92e-4599-8c15-ae55c8b8a697" />

    
    1. 웹 브라우저가 서버에 요청
    2. 서버가 해당 웹브라우저(클라이언트)에 유일한 ID(Session ID)를 부여함
    3. 서버가 응답할 때 HTTP 헤더(Set-Cokkie)에 Session ID를 포함해서 전송
    쿠키에 Session ID를 JSESSIONID라는 이름으로 저장
        
        <aside>
        
        Set-Cookie: JSESSIONID=xslei13f
        
        </aside>
        
    4. 웹 브라우저는 이후 웹 브라우조를 닫기까지 다음 요청 때 부여된 Session ID가 담겨있는 쿠키를 HTTP 헤더에 넣어서 전송
        
        <aside>
        
        Cookie: JSESSIONID=xslei13f
        
        </aside>
        
    5. 서버는 세션 ID를 확인하고, 해당 세션에 관련된 정보를 확인한 후 응답
- 세션 사용 예
    - 로그인

세션도 쿠키를 사용하여 값을 주고받으며 클라이언트의 상태 정보를 유지함
즉, 상태 정보를 유지하는 수단은 **쿠키**임

쿠키와 세션의 차이점

- 저장 위치
    - 쿠키 : 클라이언트
    - 세션 : 서버
- 보안
    - 쿠키 : 클라이언트에 저장되므로 보안에 취약함
    - 세션 : 쿠키를 이용해 Session ID만 저장하고 이 값으로 구분해서 서버에서 처리하므로 비교적 보안성이 좋음
- 라이프사이클
    - 쿠키 : 만료시간에 따라 브라우저를 종료해도 계속해서 남아있을 수 있음
    - 세션 : 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제됨
- 속도
    - 쿠키 : 클라이언트에 저장되어서 서버에 요청 시 빠르다
    - 세션 : 실제 저장된 정보가 서버에 있으므로 서버의 처리가 필요해 쿠키보다 느리다.

---

### 소켓 통신

- 네트워크에서 두 컴퓨터 간의 ‘실시간 양방향 통신’을 제공하는 기술을 의미합니다. 양방향 통신은 송신자 측이 데이터를 수신할 수도 있으며, 수신자 측이 데이터를 송신할 수 있는 구조를 가집니다.
- 두 컴퓨터 간에는 ‘특정 IP 주소와 포트번호’의 조합으로 네트워크 간의 연결을 수행하며, 수신자(클라이언트)는 데이터를 요청하면 송신자(서버)에서는 요청에 대한 응답을 제공해주는 ‘클라이언트-서버’ 모델을 사용하여 데이터를 송수신할 수 있습니다.
- 소켓 통신은 TCP와 UDP라는 두 가지 주요 프로토콜을 사용할 수 있습니다. 이러한 프로토콜을 통해 웹 서버, 이메일 서버, 데이터베이스 서버 등 다양한 응용 프로그램에서 사용되며 실시간 통신, 스트리밍, 온라인 게임 등에서도 사용됩니다.

<img width="1200" height="1512" alt="image" src="https://github.com/user-attachments/assets/ebe8107e-f7d6-4055-979d-7604537425b9" />


| 용어 | 설명 |
| --- | --- |
| 패킷(Packet) | 네트워크를 통해 전송되는 데이터의 기본단위를 의미합니다. 하나의 정보는 여러 개의 패킷으로 나누어져 전송되며, 출발지와 목적지 정보(메타데이터)와 실제 전송되는 데이터(페이로드)로 구성이 되어 있습니다. |
| 소켓(Socket) | 네트워크를 통해 데이터(패킷)을 전송하기 위한 일종의 ‘통로’를 의미합니다. |
| 채널(Channel) | 서버와 클라이언트 간에 데이터를 주고 받는 전송 경로를 의미합니다. 이 채널을 통해 데이터는 송신자에서 수신자로 전달되며, 데이터의 전송방향(일방향 또는 양방향)과 전송 모드(단일 대화 또는 다중 대화)에 따라 구분될 수 있습니다. |
| 클라이언트(Client) | 데이터를 요청하는 측으로 서버와 연결을 하여 서버로부터 데이터를 받는 역할을 수행합니다. |
| 서버(Server) | 데이터를 요청 받아 응답하여 클라이언트에게 데이터를 전송하는 역할을 수행합니다. |
| TCP(Transmisssion Control Protocol) | 연결 지향적인 프로토콜로, 데이터를 전송하기 전에 송신자와 수신자 간의 연결을 설정합니다. 그 후 패킷으로 나누어 전송하고 패킷이 수신자에게 전송되었는지 확인합니다. |
| UDP(User Datagram Protocol) | 비연결 지향적인 프로토콜로, 패킷을 수신자에게 보내고 패킷이 정확하게 도착했는지 확인하지 않습니다. TCP보다는 빠르지만 패킷 순서나 손실에 대한 보장이 없어 신뢰성이 낮습니다. |
| HandShake | 각각 네트워크에서 연결을 설정하는 단계를 의미합니다. 이는 통신이 시작되기 전에 두 장치 사이에 통신 세션을 설정하고 서로 데이터 전송을 준비하는 과정을 의미합니다. |

### 소켓 통신 수행과정 (송신, 수신 측 관점)

**소켓 통신 수행과정 : 송신 측 관점(Client Socket)**

<img width="997" height="1323" alt="image" src="https://github.com/user-attachments/assets/36ab25f5-ed46-4289-b42a-d6f54a8049d5" />


1. 클라이언트 소켓 생성 : socket()
    - 송신 측인 클라이언트에서 소켓을 생성합니다. 이 소켓은 서버에 연결 요청을 보내기 위해 사용이 됩니다.
2. 연결 요청 : connect() (3-way handshake 수행)
    - 클라이언트는 생성한 소켓을 사용하여 서버에 연결 요청을 보냅니다. 이 요청에는 클라이언트 IP 주소와 포트 번호가 포함되어 있습니다.
    - 서버는 요청을 받고, 클라이언트의 IP 주소와 포트 번호를 사용하여 새로운 소켓을 생성합니다. 이를 통해 특정 클라이언트와의 통신에 사용이 됩니다.
3. 데이터 전송 : write()
    - 클라이언트에서 소켓을 통해서 데이터를 서버로 전송합니다.
    - 해당 데이터는 패킷 단위로 전송되며, 각 패킷은 보내는 측의 IP 주소와 포트 번호, 받는 측의 IP 주소와 포트 번호, 데이터 등의 정보를 포함합니다.
4. 데이터 수신 : read()
    - 클라이언트의 요청에 따른 서버의 응답 값을 전달 받습니다.
5. 연결 종료 요청 : close() (4-Way HandShake)
    - 클라이언트는 서버에게 더 이상 데이터를 보내지 않겠다는 FIN 패킷을 보냅니다.

---

**소켓 통신 수행 과정 : 수신 측 관점 (Server Socket)**

<img width="997" height="1323" alt="image" src="https://github.com/user-attachments/assets/ab477ed4-ba41-4f4f-81cd-f3fe6ecb765f" />


1. 서버 소켓 생성 : socket()
    - 수신 측인 서버에서 소켓을 생성합니다. 이 소켓은 클라이언트의 연결 요청을 확인하기 위해 사용됩니다.
2. 서버 소켓 바인딩 : bind()
    - 생성한 소켓을 서버의 특정 IP 주소와 포트 번호에 연결합니다. 이 과정을 통해 외부의 연결 요청을 해당 서버의 IP 주소와 포트 번호로 받을 수 있게 됩니다.
3. 클라이언트 요청 대기 : listen()
    - 서버가 클라이언트의 연결 요청을 기다립니다. 이 과정에서 서버는 동시에 처리 가능한 연결 요청의 수를 지정할 수 있습니다.
4. 클라이언트 요청 수락 : accept() (3-Way HandShake)
    - 서버가 클라이언트의 연결 요청을 수락합니다. 연결이 수락되면, 서버는 클라이언트와의 통신을 위한 새로운 소켓을 생성하게 됩니다.
5. 데이터 수신 : read()
    - 서버가 클라이언트로부터 전송된 데이터를 읽습니다. 이 과정에서 서버는 클라이언트가 보낸 데이터를 처리하고 적절한 응답을 준비합니다.
6. 데이터 전송 : write()
    - 서버가 클라이언트에게 데이터를 전송합니다. 이 과정에서 서버는 클라이언트에게 응답을 보내주거나 추가 정보를 요청합니다.
7. 데이터 수신 : read()
    - 서버가 클라이언트의 추가 요청이나 응답을 읽습니다. 필요한 경우, 이 과정은 여러 번 반복될 수 있습니다.
8. 연결 종료 : close() (4-Way HandShake)
    - 통신이 끝난 후, 서버는 소켓을 닫습니다. 이렇게 하면 해당 소켓으로의 모든 입출력 오퍼레이션이 중단되고, 더 이상 클라이언트와 통신할 수 없게 됩니다.

https://digitalbourgeois.tistory.com/478
