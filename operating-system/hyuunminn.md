## 📌 시스템 콜

### OS-001

시스템 콜이 무엇인지 설명해 주세요.

- 정답
    
    운영체제의 커널이 제공하는 커널 레벨의 서비스를 응용 프로그램이 사용할 수 있도록 커널에 접근하게 해주는 인터페이스
    

### OS-002

우리가 사용하는 시스템 콜의 예시를 들어주세요.

- 정답
    - 프로세스 관리
        - fork()
        - exec()
        - wait()
        - exit()
    - 파일 관리
        - open()
        - read()
        - write()
        - close()
        - unlink()
    - 장치 관리
        - ioctl(): 장치의 특성이나 동작을 제어
    - 정보 유지
        - getpid()
        - getuid()
        - getgid()
    - 메모리 관리
        - mmap(): 파일을 메모리에 매핑하여 직접 접근할 수 있도록 함
        - munmap(): 매핑된 메모리 영역을 해제
        - brk(): 힙의 끝을 조정하여 동적 메모리를 관리
    
### OS-003
    

시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요.

- 정답
    1. 응용 프로그램 호출
        - 응용 프로그램에서 시스템 콜을 호출하면, 해당 시스템 콜의 번호가 CPU 레지스터에 저장
    2. 모드 전환
        - 사용자 모드 → 커널 모드로 전환. 이 과정은 CPU에 의해 자동으로 처리되며, 권한이 낮은 사용자 모드에서 권한이 높은 커널 모드로 전환
    3. 시스템 콜 처리
        - 해당 시스템 콜 번호에 기반하여 적절한 처리 수행. 이 과정에서 운영 체제의 커널이 특정 기능을 실행
    4. 결과 반환
        - 시스템 콜이 완료되면, 결과가 사용자 프로그램에 반환. 이때 다시 사용자 모드로 전환

### OS-004

시스템 콜의 유형에 대해 설명해 주세요.

- 정답
    1. 프로세스 관리
    2. 장치 관리
    3. 파일 관리
    4. 정보 유지
    5. 메모리 관리

### OS-005

운영체제의 Dual Mode 에 대해 설명해 주세요.

- 정답
    
    **운영체제를 보호하기 위한 기법**
    
    사용자와 운영체제는 시스템 자원을 공유한다. 그렇기 때문에 사용자에게 제한을 두지 않으면, 사용자가 메모리 내의 주요 운영체제 자원을 망가뜨릴 수 있음. 즉, 운영체제의 원활한 작동과 기능을 위해서는 사용자의 시스템 자원 접근을 제한하는 보호 장치가 필수적임
    
    - 커널모드
        - 운영체제를 위한 동작을 담당
        - 시스템의 모든 메모리에 접근 가능
        - 모든 CPU 명령을 수행 가능
    - 유저모드
        - 사용자를 위한 동작 담당
        - 사용자 애플리케이션 코드가 실행
        - 시스템 데이터에 제한된 접근만이 허용
        - 하드웨어에 직접적인 접근 불가

### OS-006

왜 유저모드와 커널모드를 구분해야 하나요?

- 정답
    
    커널에서 중요한 자원을 관리하기 때문에, 사용자가 함부로 중요한 자원에 접근하지 못하도록 하기 위해서 
    

### OS-007

서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?

- 정답
    
    시스템 콜 ID를 사용하여 서로 다른 시스템 콜을 구분하고 식별
    
    1. 고유 번호 할당
        - 각 시스템 콜마다 번호가 전부 부여되어 있음
    2. 시스템 콜 테이블
        - 커널 내부에 이 시스템 콜 번호와 실제 해당 서비스를 처리하는 커널 함수의 주소를 매핑해 놓은 **시스템 콜 테이블** 자료구조(배열 or 해시맵)가 존재
    3. 시스템 콜 호출 및 번호 전달 과정
        - 라이브러리 함수 호출
            - 응용 프로그램이 C 라이브러리 함수를 호출
        - 번호 준비
            - 시스템 콜의 고유 번호를 CPU 레지스터 같은 특정 위치에 적재하고, 시스템 콜에 필요한 매개변수도 함께 레지스터나 스택에 저장
        - 모드 전환
            - 인터럽트 실행
        - 커널 진입
            - 커널모드로 전환하고, 시스템 콜 처리 루틴 실행 (인터럽트 서비스 루틴 이었나…?)
        - 함수 실행
            - 커널은 시스템 콜 번호를 확인하고, 시스템 콜 테이블에서 해당 번호에 매핑된 커널 함수르 ㄹ호출하여 서비스를 처리

---

## 📌 인터럽트

### OS-008

인터럽트가 무엇인지 설명해 주세요.

- 정답
    
    프로그램을 실행하는 도중 예기치 못한 상황이 발생할 경우, 현재 실행중인 작업을 일시 중단하고 발생된 상황을 우선 처리한 후 실행중이던 작업으로 복귀하여 계속 처리하는 것
    

### OS-009

인터럽트는 어떻게 처리하나요?

- 정답
    
    인터럽트를 받을 경우, 인터럽트 서비스 루틴(ISR) 실행 - 처리 완료 후 원래 하던 작업 복귀
    
    - 꼬리질문 1. ISR에 대해서 자세하게 설명해주세요.

### OS-010

Polling 방식에 대해 설명해 주세요.

- 정답
    
    CPU가 주기적으로 I/O 장치의 상태를 확인하여 데이터 전송 준비가 되었는지 또는 오류가 발생했는지 능동적으로 검사하는 방식
    
    현대의 고성능 운영체제에서는 CPU의 효율성을 높이기 위해 Polling 보다는 Interrupt 방식을 선호
    

### OS-011

HW / SW 인터럽트에 대해 설명해 주세요.

- 정답
    
    위 구분은 발생 원인에 따른 인터럽트의 구분이다.
    
    1. 하드웨어 인터럽트
        - CPU 외부의 하드웨어 장치에서 발생하는 비동기적 신호
        - CPU가 무슨 작업을 하든 상관없이 언제든 발생할 수 있음
        - 하드웨어 장치가 CPU의 특정 인터럽트 핀에 전기 신호를 보내 요청
    2. 소프트웨어 인터럽트
        - CPU 내부의 프로그램 실행 과정 중에 발생하는 동기적 신호
        - 명령어의 실행 결과나 프로그램 코드에 의해 발생
        - 특별한 명령어(syscall, int)를 실행하거나, 잘못된 연산을 수행할 때 CPU가 자동적으로 발생시킴

### OS-012

동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요?

- 정답
    
    미리 정해진 우선순위에 따라 가장 중요한 인터럽트를 먼저 처리함
    
    **인터럽트 제어기(Interrput Controller)**라는 하드웨어 장치를 사용하여 여러 인터럽트 요청을 받아들이고, 그 중 가장 높은 우선순위의 신호를 CPU에 전달함
    
    1. 인터럽트 요청
    2. 우선순위 결정
    3. CPU 통보
    4. ISR 실행
    - 꼬리질문 2. 인터럽트가 처리되는 도중에 더 높은 우선순위의 인터럽트가 들어오면 어떡할 것인가?

https://kosaf04pyh.tistory.com/197

---

## 📌 프로세스

### OS-013

프로세스가 무엇인가요?

- 정답
    - 실행중인 프로그램을 의미
    - 운영체제로부터 할당받은 자원을 사용하여 CPU에서 실행되는 작업의 단위

### OS-014

프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.

- 정답
    
    프로그램
    
    - 보조 저장 장치(HDD, SSD)에 저장되어 있는 코드와 데이터의 덩어리
    - 단순히 명령어의 집합을 담고 있는 정적인 파일
    
    프로세스
    
    - 실행 중인 프로그램의 인스턴스
    - OS로부터 CPU, 메모리 등의 시스템 자원을 할당받은 작업의 독립적인 단위
    
    스레드
    
    - 프로세스 내에서 실행되는 실행 흐름의 단위
    - 프로세스가 할당받은 자원들을 이용하여 실제로 명령어를 실행하는 가장 작은 단위
    - 스레드는 프로세스 내의 Heap, Code, Data 영역을 공유 But Stack은 공유 ❌

### OS-015

PCB가 무엇인가요?

- 정답
    
    운영체제가 프로세스를 관리하고 추적하는 데 필요한 모든 정보를 저장하는 자료구조
    
    - 모든 프로세스는 생성될 때 고유한 PCB를 할당받음
    - 프로세스가 종료될 때까지 함께 존재
    
    저장되는 주요 정보
    
    - 프로세스 ID
    - 부모 프로세스 ID
    - 사용자 ID
    - 프로세스 상태
    - PC
    - 레지스터 값

### OS-016

그렇다면, 스레드는 PCB를 갖고 있을까요?

- 정답
    
    필요없음.
    
    자신을 포함하는 프로세스의 PCB를 공유하여 이용하면 됨
    
    하지만, 독립적인 실행 흐름을 유지하기 위해 TCB를 가짐
    

### OS-017

리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?

- 정답
    - 프로세스는 `fork()` 시스템 콜로 생김
    - 스레드는 `pthread_create()` 시스템 콜로 생김

### OS-018

자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?

- 정답
    
    자식 프로세스가 상태를 알리지 않고 죽는 경우 - 좀비 프로세스
    
    부모 프로세스가 먼저 죽는 경우 - 고아 프로세스
    
    1. 좀비 프로세스
        - 정확히 말하면 부모가 자식의 종료 상태를 회수하지 않은 경우
        - 자식이 종료하면 부모 프로세스가 자식 프로세스의 종료 상태를 확인하고 회수해야 함 (그래야 PCB가 회수됨)
        - 문제점
            - 좀비 프로세스가 많아지면, 사용 가능한 PID가 고갈되어 시스템이 새로운 프로세스를 생성하지 못하는 경우가 생김
    2. 고아 프로세스
        - 부모가 자식보다 먼저 종료되는 경우
        - init 프로세스(최상단)가 시스템 콜을 호출하여 종료 상태를 전부 회수하고 PCB를 정리함
        - 문제점
            - 고아 프로세스가 종료해서 좀비 프로세스가 되면, 종료 상태를 회수해 줄 부모가 없기 때문에 시스템에 영원히 PID를 점유할 수도 있음

### OS-019

리눅스에서, 데몬프로세스에 대해 설명해 주세요.

- 정답
    
    백그라운드에서 실행되며 사용자 요청이나 특정 시스템 이벤트에 응답하여 지속적으로 특정 서비스나 작업을 수행하는 프로세스
    

### OS-020

리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.

- 정답
    - 18번 질문에서 나왔던 init 프로세스가 루트이다.
    - 루트의 최상단 프로세스기 때문에 부모 프로세스가 없음.
    - 커널이 실행되고 시스템이 정상적으로 작동하는 데 필요한 모든 핵심 서비스를 실행하고 관리
    - 역할
        - 고아 프로세스 재입양
        - 좀비 프로세스 회수
    
    꼬리질문 3. 보통의 프로세스 생성은 부모 프로세스의 `fork()`를 통해 생성된다. 그러면 init 프로세스는 부모가 없는 루트 프로세스인데, 이건 어떻게 생성되는건가?
    

---

## 📌 프로세스 주소공간

### OS-021

프로세스 주소공간에 대해 설명해 주세요.

- 정답
    
    프로세스가 메모리를 할당 받으면, 그 메모리를 관리하기 위해 프로세스가 사용하는 구조
    
    - (위) 스택 - 힙 - 데이터 - 텍스트 (아래) 구조
    - 스택 영역(Stack)
        - 함수의 호출과 관계되는 지역변수와 매개변수가 저장되는 영역
        - 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸
        - 메모리의 높은 주소 → 낮은 주소로 할당
    - 힙 영역(Heap)
        - 런타임에 크기가 결정됨
        - 사용자에 의해 공간이 동적으로 할당 및 해제됨
        - 참조형 데이터(클래스) 등의 데이터가 할당
        - 낮은 주소 → 높은 주소로 할당
    - 데이터 영역(Data)
        - 전역 변수, Static 변수 등 프로그램이 사용할 수 있는 데이터를 저장하는 영역
        - 프로그램의 시작과 함께 할당, 종료되면 소멸
    - 텍스트 영역(Text)
        - 프로그램이 실행될 수 있도록 CPU가 해석 가능한 기계어 코드가 저장되어 있는 공간
        - 프로그램이 수정되면 안 되므로 ReadOnly 상태임

### OS-022

초기화 하지 않은 변수들은 어디에 저장될까요?

- 정답
    
    초기화되지 않은 전역 변수 + 정적 변수
    
    BSS 영역 (Blocked Started by Symbol)
    

### OS-023

일반적인 주소공간 그림처럼, Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? 그렇지 않다면, 그 크기는 언제 결정될까요?

- 정답
    - 힙 영역의 크기는 런타임 시 결정됨
    - 스택 영역의 크기는 컴파일 시점에 결정됨
    - 무한히 증가하는 것이 아니라, 미리 설정된 최대 크기를 초과하거나, 힙 영역과 충돌하게 되면 **스택 오버플로우**가 발생

### OS-024

Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?

- 정답
    
    Stack이 더 빠름
    
    - Stack은 LIFO 원칙에 따라 데이터를 추가, 제거함
    - Heap은 프로그램의 요청에 따라 비연속적인 메모리 공간에서 적절한 크기의 빈 공간을 찾아 할당
    
    → 당연히 Stack이 더 빠름
    

### OS-025

다음과 같이 공간을 분할하는 이유가 있을까요?

- 정답
    
    시스템의 안정성, 효율성, 유연성을 극대화하기 위해
    
    1. 안정성
        - 코드 영역과 데이터 영역의 분리를 통해 명령어 코드가 실수나 악의적으로 변경되는 것을 방지
    2. 효율성
        - 코드 영역은 실행 중인 프로세스가 동일한 코드를 공유할 수 있도록 함
        - 메모리에 코드를 단 한번만 로드하고 여러 프로세스가 공유하여 메모리 사용량을 절약할 수 있음
    3. 유연성
        - 힙과 스택 영역은 서로 반대 방향으로 자라도록 배치
        - 프로그램 요구에 따라 필요한 만큼 크기를 동적으로 확장할 수 있음

### OS-026

스레드의 주소공간은 어떻게 구성되어 있을까요?

- 정답
    
    공유 영역과 개별 영역으로 구성
    
    공유 영역
    
    - 코드 영역
    - 데이터 영역
    - 힙 영역
    
    개별 영역
    
    - 스택 영역

### OS-027

"스택"영역과 "힙"영역은 정말 자료구조의 스택/힙과 연관이 있는 걸까요? 만약 그렇다면, 각 주소공간의 동작과정과 연계해서 설명해 주세요.

- 정답
    
    스택은 LIFO 원칙을 그대로 따르기 때문에 자료구조와 관련이 있음
    
    힙은 빈 공간을 찾아 불규칙적으로 메모리가 할당되기 때문에 FIFO와 관련 ❌
    

### OS-028

IPC의 Shared Memory 기법은 프로세스 주소공간의 어디에 들어가나요? 그런 이유가 있을까요?

- 정답

### OS-029

스택과 힙영역의 크기는 언제 결정되나요? 프로그램 개발자가 아닌, 사용자가 이 공간의 크기를 수정할 수 있나요?

- 정답
    - 힙 영역의 크기는 런타임 시 결정됨
    - 스택 영역의 크기는 컴파일 시점에 결정됨

---

## 📌 CPU 스케줄링

### OS-030

단기, 중기, 장기 스케쥴러에 대해 설명해 주세요.

- 정답
    1. 장기 스케줄러
        - 디스크에 저장된 프로그램 중 어떤 것을 선택하여 RAM으로 로드할지 결정하여 프로세스를 생성
    2. 중기 스케줄러
        - 시스템의 메모리 부족 문제를 해결하고 멀티프로그래밍 정도를 동적으로 관리하기 위해, 메모리에 있는 프로세스 중 일부를 선택하여 보조 저장 장치(디스크)로 내보내거나 다시 불러들임
    3. 단기 스케줄러
        - Ready 상태에 있는 프로세스들 중에서 어떤 프로세스에게 CPU를 할당할지 결정하고 실행

### OS-031

현대 OS에는 단기, 중기, 장기 스케쥴러를 모두 사용하고 있나요?

- 정답
    
    1. 단기 스케줄러 - **필수**
    
    - **사용 여부:** **항상 사용**
    - **역할:** 단기 스케줄러는 준비(Ready) 상태의 프로세스 중 CPU를 할당할 대상을 선택하는 **CPU 스케줄링**을 담당함. 이는 멀티태스킹 시스템의 **핵심 기능**이며, 시스템의 응답성과 효율성을 결정짓기 때문에 모든 현대 OS에서 필수적으로 사용됨
    
    2. 중기 스케줄러 - **주로 사용**
    
    - **사용 여부:** 대부분의 OS에서 **사용**
    - **역할:** 중기 스케줄러는 시스템의 **메모리 부하**를 관리하기 위해 프로세스를 메모리에서 디스크로 내보내거나(`Swapping Out`) 다시 불러들이는(`Swapping In`) 역할을 함. 현대 OS는 대부분 가상 메모리 시스템을 사용하며, 메모리가 부족할 때 프로세스를 일시 중단 상태로 전환하여 메모리를 확보하는 이 스와핑(Swapping) 메커니즘을 적극적으로 활용함.
    
    3. 장기 스케줄러 - **사용 감소/제한적 사용**
    
    - **사용 여부:** **제한적이거나 사용하지 않음.**
    - **역할 축소 이유:**
        1. **배치 시스템의 감소:** 장기 스케줄러는 원래 **배치 처리 시스템**에서 디스크에 쌓인 Job을 선택하여 메모리로 로드하는 역할을 했음. 현대 OS는 주로 대화형 시스템이며, 프로그램이 실행 요청과 함께 즉시 메모리에 로드되어 프로세스로 생성됩니다.
        2. **메모리 및 CPU 성능 향상:** 현대 시스템은 메모리 용량이 크고 CPU 성능이 매우 뛰어나기 때문에, 수용 가능한 프로세스 수를 사전에 엄격하게 통제할 필요성이 크게 줄었음.
    
    따라서 대부분의 일반적인 리눅스, 윈도우, macOS와 같은 **시분할(Time-Sharing) 및 대화형 OS**에서는 **장기 스케줄러의 기능이 중기 스케줄러나 로더(Loader)에 통합**되어 있거나, 아예 독립적인 형태로 존재하지 않는 경우가 많음.
    

### OS-032

프로세스의 스케쥴링 상태에 대해 설명해 주세요.

- 정답
    1. 생성(New)
        - 프로세스가 막 생성되어 준비 중인 초기 상태
    2. 준비(Ready)
        - 프로세스가 CPU를 할당받아 즉시 실행될 수 있도록 모든 준비를 마친 상태
    3. 실행(Running)
        - 프로세스가 CPU를 할당받아 명령어를 실제로 실행하고 있는 상태
    4. 대기(Waiting/Blocked)
        - 프로세스가 CPU 실행은 가능하지만, 특정 사건(이벤트)이 발생하기를 기다리는 상태
    5. 종료(Terminated)
        - 프로세스가 실행을 완료하고 시스템으로부터 모든 자원을 해제한 상태

### OS-033

preemptive/non-preemptive 에서 존재할 수 없는 상태가 있을까요?

- 정답
    
    비선점형(non-preemptive)는 CPU를 강제로 빼앗을 수 없기 때문에, 준비 상태 → 실행 상태 전이가 불가능함
    

### OS-034

Memory가 부족할 경우, Process는 어떠한 상태로 변화할까요?

- 정답
    
    시스템에 메모리 부하가 심해질 경우, 프로세스는 주로 중단(Suspended) 상태로 전환됨
    
    이때, 중기 스케줄러가 개입하여 Swapping을 통해 중단 상태로 전환됨
    
    이후에 메모리 상황이 개선되면, 중기 스케줄러가 중단된  프로세스를 다시 메모리로 불러와 준비 or 대기 상태로 복귀 시킴(Swapping in)
    

---

## 📌 컨텍스트 스위칭

### OS-035

컨텍스트 스위칭 시에는 어떤 일들이 일어나나요?

- 정답
    1. 현재 문맥 저장
        - 현재 실행 중인 프로세스의 상태 정보를 PCB 또는 TCB에 저장
    2. 다음 프로세스 선택 및 전환
        - 운영체제의 스케줄러가 다음으로 CPU를 할당받을 새로운 프로세스를 준비 큐에서 선택
    3. 새 문맥 복원
        - 새로운 프로세스의 PCB/TCB에 저장되어 있던 과거 문맥 정보를 CPU 레지스터로 로드

### OS-036

프로세스와 스레드는 컨텍스트 스위칭이 발생했을 때 어떤 차이가 있을까요?

- 정답
    1. 메모리 관리 정보 교환
        - 메모리 관리 정보의 변경 여부
        - 프로세스: 각 프로세스는 독립적인 가상 주소 공간을 가지고 있음. 따라서 컨텍스트 스위칭 시, 운영체제는 CPU의 페이지 테이블 레지스터를 새로운 프로세스의 페이지 테이블 주소로 바꿔야 함
        - 스레드: 같은 프로세스 내의 스레드들은 동일한 주소 공간을 공유함. 따라서 스위칭 시 페이지 테이블을 변경할 필요가 없음
    2. 제어 블록 정보 교환 범위
        - 프로세스: PCB에 저장된 모든 정보를 저장하고 복원해야 함
        - 스레드: TCB에 저장된 실행 흐름 관련 정보와 개별 스택 영역만 교체하면 됨

### OS-037

컨텍스트 스위칭이 발생할 때, 기존의 프로세스 정보는 커널스택에 어떠한 형식으로 저장되나요?

- 정답
    
    스택 프레임 형태를 따르며, 이는 PCB 또는 TCB에 저장되는 포인터 정보와 함께 문맥을 구성함
    

### OS-038

컨텍스트 스위칭은 언제 일어날까요?

- 정답
    
    운영체제가 현재 CPU를  사용하는 프로세스의 제어권을 다른 프로세스로 넘겨야 할 때 발생
    
    1. 타이머 인터럽트
    2. I/O 또는 이벤트 대기
    3. 인터럽트 또는 시그널 발생
    4. 시스템 콜 종료 후

---

## 📌 스케줄링 알고리즘

### OS-039

프로세스 스케줄링 알고리즘에는 어떤 것들이 있나요?

- 정답
    1. 선점형 알고리즘
        - SRTF (Shortest Remaining Time First)
        - Priority Scheduling (우선순위)
        - Round Robin (RR)
    2. 비선점형 알고리즘
        - FCFS (First Come, First Served)
        - SJF (Shortest Job First)
    3. 복합적 알고리즘
        - 다단계 큐 (Multi-Level Queue)
        - 다단계 피드백 큐 (Multi-Level Feedback Queue)

### OS-040

RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요.

- 정답
    1. Time Slice가 짧을 때
        - 장점
            - 빠른 응답 시간
            - 공평성 증가
        - 단점
            - 컨텍스트 스위칭의 비용이 많이 발생함
            - 오버헤드 커짐
    2. Time Slice가 길 때
        - 장점
            - 컨텍스트 스위칭 비용이 작음
            - FCFS에 수렴
        - 단점
            - 느린 응답 시간
            - I/O 집중 작업에 불리

### OS-041

싱글 스레드 CPU 에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케쥴링 알고리즘을 사용하는 것이 좋을까요? 또 왜 그럴까요?

- 정답
    
    비선점형 우선순위 스케줄링
    
    - 오버헤드 최소화
        - 만약 선점형 방식을 사용한다면, 일정 시간 간격으로 타이머 인터럽트가 발생하고 불필요한 컨텍스트 스위칭이 발생함

### OS-042

동시성과 병렬성의 차이에 대해 설명해 주세요.

- 정답
    - 동시성은 단일 코어 CPU 환경에서도 여러 작업을 동시에 진행되는 것처럼 보이게 만드는 능력을 말함
    - 병렬성은 다중 코어 CPU나 다중 프로세서 환경에서 여러 작업을 물리적으로 동시에 실행하는 능력을 말함

### OS-043

타 스케쥴러와 비교하여, Multi-level Feedback Queue는 어떤 문제점들을 해결한다고 볼 수 있을까요?

- 정답
    1. 예측 불가능성 문제 해결 (SJF의 한계)
        - 동적 강등 (Dynamic Demotion)
            - CPU 버스트 시간을 명시적으로 예측하지 않고, 프로세스의 실제 행동을 관찰하여 간접적으로 판단
    2. 기아 현상 문제 해결 (우선순위 스케줄링의 한계)
        - 에이징 (Aging)
            - 낮은 우선순위 큐에 오랫동안 대기하고 있는 프로세스의 우선순위를 점진적으로 상승시켜 높은 우선순위 큐로 이동
    3. 유연성 및 응답성 문제 해결 (단일 큐의 한계)
        - RR: 모든 작업에 동일한 시간 할당량을 주어 CPU 집중 작업이 I/O 집중 작업의 응답 시간을 지연시킬 수 있음
        - Multi-Level Queue: 한 번 큐에 할당되면 다른 큐로 이동할 수 없어, 프로세스의 특성이 변해도 대처하지 못하고 비효율적인 스케줄링 지속
        - 여러 큐와 동적 이동
            - 여러 단계의 큐를 이용하여 각 큐마다 서로 다른 스케줄링 정책을 적용하고 프로세스 이동을 허용함

### OS-044

FIFO 스케쥴러는 정말 쓸모가 없는 친구일까요? 어떤 시나리오에 사용하면 좋을까요?

- 정답
    
    FIFO가 쓸모없다고 여겨지는 주된 이유는 호그(Convoy Effect) 현상 때문임. 짧은 작업이 긴 작업 뒤에 대기해야 하므로 평균 대기 시간이 길어지고 응답성이 떨어지는 문제가 발생
    
    But 아래 경우에는 FIFO의 장점이 드러남
    
    1. 오버헤드 최소화가 가장 중요할 때
    2. 공평한 순차적 처리가 요구될 때
    3. 모든 작업의 실행 시간이 거의 비슷할 때

### OS-045

우리는 스케줄링 알고리즘을 "프로세스" 스케줄링 알고리즘이라고 부릅니다. 스레드는 다른 방식으로 스케줄링을 하나요?

- 정답
    
    현대 OS는 대부분 커널 레벨 스레드를 기본 스케줄링 단위로 사용함.
    
    따라서 프로세스 스케줄링 알고리즘은 사실상 커널 레벨 스레드 스케줄링 알고리즘을 의미하며, RR, Priority Scheduling 등의 알고리즘을 그대로 적용하여 스레드에게 CPU를 할당함
    

### OS-046

유저 스레드와 커널 스레드의 스케쥴링 알고리즘은 똑같을까요?

- 정답
    
    커널 스레드 스케줄링
    
    - 운영체제 커널의 단기 스케줄러
    - 컨텍스트 스위칭 비용이 높음
    - OS의 스케줄링 정책을 따르기 때문에, 시스템 차원에서 정의된 RR, MLFQ 등의 알고리즘을 사용
    
    유저 스레드 스케줄링
    
    - 해당 프로세스 내부의 스레드 라이브러리
    - 컨텍스트 스위칭 비용이 매우 낮음
    - 커널의 간섭 없이 라이브러리 내부에서만 관리되므로, 개발자가 자유롭게 정의한 스케줄링 로직에 따라 전환

---

## 📌 프로세스 동기화 문제

### OS-047

뮤텍스와 세마포어의 차이점은 무엇인가요?

- 정답
    
    공통점: 동기화 메커니즘으로, 다중 프로세스 또는 다중 스레드 환경에서 공유 자원에 대한 접근을 제어하여 경쟁 상태를 방지하는 데 사용
    
    뮤텍스: 상호 배제에 특하되어 하나의 스레드만 접근을 허용하고 소유권을 가짐
    
    카운팅 세마포어: 자원 개수 제어에 사용되며, 카운팅 세마포어를 통해 동시에 여러 스레드의 접근을 허용할 수 있음
    

### OS-048

이진 세마포어와 뮤텍스의 차이에 대해 설명해 주세요.

- 정답
    1. 소유권의 차이
        - 뮤텍스는 소유권 개념이 핵심. 락을 획독한 스레드가 해당 뮤텍스의 소유자가 되며, 오직 이 소유자만이 뮤텍스를 해제할 수 있음
        - 이진 세마포어는 소유권 개념이 없음. P연산(획득)을 수행한 스레드가 아니더라도, 다른 스레드가 V 연산(해제)을 수행하여 세마포어 값을 1로 만들 수 있음

### OS-049

Lock을 얻기 위해 대기하는 프로세스들은 Spin Lock 기법을 사용할 수 있습니다. 이 방법의 장단점은 무엇인가요? 단점을 해결할 방법은 없을까요?

- 정답
    
    스핀락 : 락을 획득하려는 프로세스나 스레드가 락이 해제될 때까지 반복적으로 확인
    
    1. 장점
        - 오버헤드 최소화: 컨텍스트 스위칭이 발생하지 않아 오버헤드가 매우 낮음
        - 빠른 복귀: 락이 빠르게 해제될 것으로 예상될 경우, 대기 중이던 스레드는 즉시 락을 획득하고 실행을 재개할 수 있음
        - 커널 스케줄러 독립성: 커널의 스케줄러 개입 없이 사용자 모드에서 락을 기다릴 수 있음( 다만 실제 OS 환경에서는 스핀 락도 커널에서 관리되는 경우가 많음)
    2. 단점
        - CPU 낭비: 락이 해제될 때까지 프로세스가 아무 의미 없는 루프를 돌며 CPU 시간을 낭비
        - 성능 저하: 단일 코어에서는 락을 획득하기 위해 스핀하는 프로세스가 다른 프로세스의 실행을 방해하여 전체 시스템의 처리량을 저하시킴
    3. 해결
        - 스핀락 + 블록킹 방식을 적용
            - 초기 단계: 스핀락 기법을 통해 락 해제를 기다림
            - 전환 단계: 일정 시간이 지나도 락을 획득하지 못하면, 대기(Blocked) 상태로 전환
            - 대기: 해당 프로세스는 대기 큐에 들어가 CPU를 놓아주며, 락을 소유한 프로세스가 락을 해제할 때까지 잠듦

### OS-050

뮤텍스와 세마포어 모두 커널이 관리하기 때문에, Lock을 얻고 방출하는 과정에서 시스템 콜을 호출해야 합니다. 이 방법의 장단점이 있을까요? 단점을 해결할 수 있는 방법은 없을까요?

- 정답
    
    그냥 스핀락과 반대 방식 (Blocking)임
    
    1. 장점
        - CPU 낭비를 안 함
        - 스케줄링 알고리즘을 적용하여 공평성을 보장함
    2. 단점
        - 컨텍스트 스위칭이 발생해 오버헤드가 큼
        - 시스템 콜을 호출하는 것 자체도 커널 모드로 전환하는 것이기 때문에 오버헤드가 발생
    3. 해결
    - 49번과 동일

### OS-051

Deadlock 에 대해 설명해 주세요.

- 정답
    
    다중 프로세스/스레드 환경에서 두 개 이상의 프로세스가 서로 다른 프로세스가 점유하고 있는 자원을 요청하며 무한정 대기하는 상태
    

### OS-052

Deadlock 이 동작하기 위한 4가지 조건에 대해 설명해 주세요.

- 정답
    1. 상호 배제
    2. 비선점
    3. 점유와 대기
    4. 순환 대기

### OS-053

그렇다면 3가지만 충족하면 왜 Deadlock 이 발생하지 않을까요?

- 정답
    
    순환 대기가 형성되지 않아서 프로세스가 자원을 무한정 기다리는 상태가 발생하지않음
    

### OS-054

어떤 방식으로 예방할 수 있을까요?

- 정답
    1. 예방
        - 4가지 필수 요건 중 하나 이상을 사전에 불가능하게 만듦.
        - 가장 안전하지만, 자원의 효율성을 떨어뜨릴 수 있음
    2. 회피
        - 은행원 알고리즘
        - 안전한 지 미리 검사한 후 자원을 할당
    3. 감지 및 복구
        - 시스템이 주기적으로 데드락 발생 여부를 감지하고 발생했을 경우 프로세스를 강제 종료하거나 자원을 선점

### OS-055

왜 현대 OS는 Deadlock을 처리하지 않을까요?

- 정답
    
    데드락을 감지하고 복구하는 데에는 많은 노력과 비용이 드는 데에 반해, 데드락이 발생할 확률은 매우 낮기 때문에 성능과 처리량 극대화를 위해서 재부팅 하는 방식을 선호
    

### OS-056

Wait Free와 Lock Free를 비교해 주세요.

- 정답
    
    Wait-Free와 Lock-Free 모두 멀티스레드 환경에서 락 사용을 피하고 동시성을 확보하기 위한 비차단(Non-blokcing) 동기화 기법
    
    1. Wait-Free (무한 대기 없음)
        - 모든 스레드가 유한한 시간 내에 자신의 작업을 완료함이 보장되는 알고리즘
        - 한 스레드의 지연이나 실패가 다른 어떤 스레드의 진행도 막지 못함
        - 구현이 복잡하며, 오버헤드가 큼
    2. Lock-Free (교착 상태 없음)
        - 어떤 스레드든 유한한 시간 내에 작업을 완료함이 보장되는 알고리즘. 즉, 항상 최소한 하나의 스레든느 진행함
        - 데드락이 발생하지 않음이 보장됨
        - Wait-Free 보다는 구현이 쉽고, 일반적인 비차단 동기화에서 가장 많이 사용됨

---

## 📌 컴파일

### OS-057

프로그램이 컴파일 되어, 실행되는 과정을 간략하게 설명해 주세요.

- 정답
    1. 컴파일
        1. 전처리
            - 전처리기 지시자를 처리함
        2. 컴파일
            - 전처리된 소스코드를 컴파일러가 분석하여 어셈블리어로 번역
            - 문법 오류를 검사
        3. 어셈블
            - 어셈블러가 분석하여 CPU가 직접 실행할 수 있는 기계어 코드로 변환
        4. 링크
            - 프로그램이 사용하는 다른 오브젝트 파일들을 모두 결합하여 하나의 완전한 실행 가능한 파일로 만듦
    2. 실행 과정
        1. 로드
            - 디스크에 잇는 실행파일을 찾아서 RAM의 프로세스 주소 공간에 복사
        2. 프로세스 생성
            - PCB를 생성하고, 프로세스에 고유한 PID를 할당
            - 프로세스는 준비 상태로 전환되어 CPU 할당을 기다림
        3. CPU 실행
            - CPU가 작업을 수행

### OS-058

링커와, 로더의 차이에 대해 설명해 주세요.

- 정답
    
    링커
    
    - 컴파일 과정의 마지막 단계에 동작하는 프로그램
    - 여러 개의 분리된 코드 조각들을 하나로 합쳐서 실행 가능한 파일로 만듦
    - 디스크 상의 실팽 파일을 생성하는 것
    
    로더
    
    - 프로그램 실행 과정의 첫 단계에서 동작하는 OS의 루틴
    - 디스크에 있는 실행 파일을 찾아서 RAM에 적재하고 실행을 시작하는 역할
    - 프로그램을 메모리 내 프로세스로 만드는 것

### OS-059

컴파일 언어와 인터프리터 언어의 차이에 대해 설명해 주세요.

- 정답
    
    컴파일 언어
    
    - 프로그램을 실행하기 전에 전체 소스 코드를 한 번에 기계어로 변환하는 과정을 거침
    - 이미 기계어로 번역되어 있으므로 실행 시점에 추가적인 번역이 불필요해 빠름
    
    인터프리터 언어
    
    - 프로그램을 실행하는 동안 한 줄씩 또는 명령어 단위로 번역과 실행을 동시에 진행
    - 실행할 때마다 번역을 반복해야 하므로 느림

### OS-060

JIT에 대해 설명해 주세요.

- 정답
    
    인터프리터 언어의 유연성과 컴파일 언어의 실행 속도를 결합하기 위해 고안된 기술
    
    작동 원리
    
    1. 초기 번역
    2. 인터프리팅 및 분석
    3. 핫 스팟 감지
    4. 실행 직전 컴파일
    5. 캐싱 및 재사용

### OS-061

본인이 사용하는 언어는, 어떤식으로 컴파일 및 실행되는지 설명해 주세요.

- 정답
    
    JIT 방식을 사용하여 컴파일됨
    

### OS-062

Python 같은 언어는 CPython, Jython, PyPy등의 다양한 구현체가 있습니다. 각각은 어떤 차이가 있을까요? 또한, 실행되는 과정 또한 다를까요?

- 정답
    
    CPython은 인터프리팅 방식, Jython은 JVM을 이용한 자바 바이트 코드 방식, PyPy는 자체 JIT 컴파일러를 이용한 방식으로 파이썬 코드를 실행하며, 각각의 환경과 목적에 따라 다른 실행 과정을 거침
    

### OS-063

우리는 흔히 fork(), exec() 시스템 콜을 사용하여 프로세스를 적재할 수 있다고 배웠습니다. 로더의 역할은 이 시스템 콜과 상관있는 걸까요? 아니면 다른 방식으로 프로세스를 적재할 수 있는 건가요?

- 정답
    
    fork()는 로더의 역할과는 직접적인 관련이 없음
    
    - fork()는 현재 실행 중인 부모 프로세스의 메모리 구조를 복사하여 동일한 이미지를 가진 자식 프로세스를 생성
    - 이 단계는 적재보다 복제에 중점을 둠
    
    exec()는 호출 순간에 운영체제 커널 내부의 로더가 활성화되어 핵심적인 적재 및 실행 작업을 수행함
    
    - exec는 현재 프로세스의 메모리 공간을 새로운 프로그램의 이미지로 완전히 덮어쓰기 위해 사용됨
    - 로더의 역할
        - 메모리 해제
        - 새 파일 읽기
        - 적재 및 매핑
        - 실행 시작
    - exec()는 로더의 기능을 커널 내부에서 시스템 콜의 형태로 구현한 것

---
